<script>
    // Global object to store Highcharts instances
    window.highchartInstances = {};

    // Global variables for tracking chart-related data
    let chartCounter = 0;
    let chartDataTemp = {}; // Temporary storage for chart input data
    let currentChartType = null; // Store the current chart type globally
    let pendingChartData = null;
    let pendingChartType = null;
    let pendingChartId = null;
    let commentMode = false; // Initialize the commentMode variable

    // Global array to store Highcharts data
    let highchartsDataArray = [];

    // Define the business metrics categories and corresponding metrics
    const businessMetrics = {
        sales: ["Units Sold", "Sales Revenue"],
        marketing: ["Leads", "Conversion Rate"],
        financial: ["Revenue", "Profit"],
        customer: ["Satisfaction", "Retention"],
        website: ["Visitors", "Bounce Rate"],
        operational: ["Efficiency", "Output"],
        hr: ["Employee Count", "Turnover Rate"],
        it: ["Incidents", "Resolution Time"],
        health_safety: ["Incidents", "Lost Time"]
    };

    // Declare the grid variable in the global scope for later initialization
    let grid;

    // Utility function to place the caret at the end of an editable element
    function placeCaretAtEnd(el) {
        console.log('Placing caret at the end of element:', el);
        el.focus();
        if (typeof window.getSelection != "undefined" && typeof document.createRange != "undefined") {
            const range = document.createRange();
            range.selectNodeContents(el);
            range.collapse(false);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        } else if (typeof document.body.createTextRange != "undefined") {
            const textRange = document.body.createTextRange();
            textRange.moveToElementText(el);
            textRange.collapse(false);
            textRange.select();
        }
    }

    // Utility function to generate a Highcharts chart
    function generateHighcharts(container, type, chartData, showTitle = true, title = '', highchartsId = null) {
        console.log('Generating Highcharts for container:', container, 'Type:', type, 'Data:', chartData);

        const categories = chartData.data.months;
        const series = chartData.data.units_sold.map(item => ({ name: item.region || item.category, data: item.values }));

        const options = {
            chart: { type: type, renderTo: container.id },
            title: { text: showTitle ? title : null }, // Set the title text here
            xAxis: { categories: categories },
            yAxis: { title: { text: chartData.metadata.units } },
            series: series
        };

        console.log('Chart options:', options);
        const chart = Highcharts.chart(options);

        // Use the provided highchartsId if available, otherwise use the newly created chart index
        const highchartsIndex = highchartsId !== null ? highchartsId : chart.index;
        container.setAttribute('data-highcharts-chart', highchartsIndex);

        // Store the Highcharts instance using the container's ID as the key
        window.highchartInstances[container.id] = chart;
        // Store chart data in temporary storage using the container's ID
        chartDataTemp[container.id] = chartData;

        // Add chart data to the global highchartsDataArray
        highchartsDataArray.push({
            containerId: container.id,
            options: chart.options
        });

        // Log container ID and Highcharts index
        console.log('Chart generated in container ID', container.id, 'with Highcharts index', highchartsIndex);

        return chart;
    }

    // Utility function to get complete chart options
    function getCompleteChartOptions(chart) {
        return {
            chart: chart.options.chart,
            title: chart.options.title,
            subtitle: chart.options.subtitle,
            series: chart.options.series,
            xAxis: chart.options.xAxis,
            yAxis: chart.options.yAxis,
            legend: chart.options.legend,
            tooltip: chart.options.tooltip,
            plotOptions: chart.options.plotOptions,
            exporting: chart.options.exporting,
            annotations: chart.options.annotations,
            credits: chart.options.credits,
            noData: chart.options.noData,
            responsive: chart.options.responsive
        };
    }

    // Function to determine the next available position for a new widget
    function getNextPosition() {
        const items = grid.engine.nodes;
        let positions = items.map(item => ({ x: item.x, y: item.y, w: item.width, h: item.height }));
        let x = 0, y = 0;

        console.log('Determining next position...');
        console.log('Current grid positions:', positions);

        while (positions.some(pos => pos.x === x && pos.y === y)) {
            x++;
            if (x + 6 > grid.opts.column) { // Assuming 6 is the width of the widget
                x = 0;
                y++;
            }
        }

        console.log(`Next position determined: x=${x}, y=${y}`);
        return { x, y };
    }

    // Function to place the chart container into the grid
    function placeChartContainer(containerId, x, y, width, height, content) {
        console.log('Placing chart container into the grid...');
        console.log(`Container ID: ${containerId}, x: ${x}, y: ${y}, width: ${width}, height: ${height}`);

        const el = document.createElement('div');
        el.className = 'grid-stack-item ui-draggable ui-resizable ui-resizable-autohide';
        el.setAttribute('gs-w', width);  // Set width to the specified value
        el.setAttribute('gs-h', height);
        el.setAttribute('gs-x', x);
        el.setAttribute('gs-y', y);
        el.innerHTML = `
        <div class="grid-stack-item-content" style="padding: 5px;">
          ${content}
        </div>
      `;

        console.log('Element created:', el);
        console.log('Element classes:', el.className);
        return el;
    }

    // Function to initialize Highcharts using the data
    function initializeHighcharts(containerId, options) {
        const container = document.getElementById(containerId);
        if (container) {
            options.chart.renderTo = containerId; // Set the renderTo property explicitly
            try {
                console.log(`Initializing Highcharts with options:`, options);
                const chart = Highcharts.chart(options);
                Highcharts.charts[chart.index] = chart; // Re-register the chart instance

                // Ensure the chart reflows correctly and fits the container
                setTimeout(() => {
                    chart.reflow();
                    console.log(`Reflowed chart for container ID: ${containerId} with Highcharts index ${chart.index}`);
                }, 0);
            } catch (error) {
                console.error('Error recreating chart:', error, 'Options:', options);
            }
        } else {
            console.error(`Container ID ${containerId} not found in DOM.`);
        }
    }

    // Function to save layout with chart data
    function saveLayoutWithCharts() {
        console.log('Saving layout with Highcharts data...');
        const layoutName = prompt("Enter layout name:");
        if (layoutName) {
            const layout = grid.save().map(item => {
                const content = item.content; // Assume content was saved properly in the layout
                const { el, ...rest } = item; // Remove `el` from the saved item
                return { ...rest, content: content }; // Add the content to the saved item
            });

            // Update highchartsDataArray with the latest chart options
            highchartsDataArray = highchartsDataArray.map(data => {
                const chart = Highcharts.charts.find(chart => chart && chart.renderTo.id === data.containerId);
                if (chart) {
                    data.options = getCompleteChartOptions(chart);
                }
                return data;
            });

            const savedLayouts = JSON.parse(localStorage.getItem('savedLayouts')) || {};
            savedLayouts[layoutName] = {
                layout: layout,
                highchartsDataArray: highchartsDataArray
            };

            localStorage.setItem('savedLayouts', JSON.stringify(savedLayouts));
            console.log('Saved layouts in localStorage:', JSON.parse(localStorage.getItem('savedLayouts')));
        }
    }

    // Function to load layout with chart data
    function loadLayoutWithCharts(layoutName) {
        console.log('Loading saved layout...');
        const savedLayouts = JSON.parse(localStorage.getItem('savedLayouts'));
        const layoutData = savedLayouts ? savedLayouts[layoutName] : null;
        if (layoutData) {
            console.log('Loading layout data:', layoutData);
            grid.removeAll();

            // Load the saved layout
            layoutData.layout.forEach(item => {
                const el = placeChartContainer(item.containerId, item.x, item.y, item.width, item.height, item.content);
                grid.addWidget(el);
            });

            // Ensure containers are created before initializing Highcharts
            setTimeout(() => {
                layoutData.highchartsDataArray.forEach(data => {
                    initializeHighcharts(data.containerId, data.options);
                });
                updateCurrentLayoutContent();
                updateHighchartsDataArray();
            }, 1000); // Increase timeout if necessary to ensure DOM readiness
        } else {
            alert("Layout not found.");
        }
    }

    // Update function to display saved layouts
    function updateSavedLayouts() {
        console.log('Updating saved layouts...');
        const savedLayouts = JSON.parse(localStorage.getItem('savedLayouts')) || {};
        console.log('Current saved layouts:', savedLayouts);
        $('#localStorageContent').text(JSON.stringify(savedLayouts, null, 2));
    }

    // Function to update the display of the current layout content
    function updateCurrentLayoutContent() {
        console.log('Updating current layout content...');
        const layout = grid.save();
        layout.forEach(item => {
            const chartContainer = $(item.el).find('.chart-container');
            if (chartContainer.length) {
                item.containerId = chartContainer.attr('id');
                const chart = getHighchartsInstanceByContainerId(chartContainer.attr('id'));
                if (chart) {
                    item.chartOptions = chart.options; // Save chart options
                    console.log('Stored chart options for container ID:', chartContainer.attr('id'), 'with Highcharts index', chart.index);
                }
            }
        });
        console.log('Current layout content:', layout);
        $('#currentLayoutContent').text(JSON.stringify(layout, null, 2));
    }

    // Update function to display Highcharts data array
    function updateHighchartsDataArray() {
        console.log('Updating Highcharts data array...');
        console.log('Highcharts data array:', highchartsDataArray);
        $('#highchartsDataArray').text(JSON.stringify(highchartsDataArray, null, 2));
    }

    // Event handler for saving the layout
    $('#saveLayoutBtn').on('click', saveLayoutWithCharts);

    // Event handler for loading a saved layout
    $('#loadLayoutBtn').on('click', function () {
        const layoutName = prompt("Enter layout name to load:");
        if (layoutName) {
            loadLayoutWithCharts(layoutName);
        }
    });

    // Ensure the DOM is fully ready before initializing GridStack and Highcharts
    $(function () {
        console.log('Initializing GridStack...');
        grid = GridStack.init({
            cellHeight: 70,
            acceptWidgets: true,
            removable: true,
            removeTimeout: 100,
            dragIn: '.newWidget',
            dragInOptions: { revert: 'invalid', scroll: false, appendTo: 'body', helper: 'clone' },
            disableResize: false,  // Ensure resizing is not disabled
        });

        // Event handler for changing the selected business area
        $('#businessAreaSelect').on('change', function () {
            const businessArea = $(this).val();
            const metrics = businessMetrics[businessArea];
            console.log('Selected business area:', businessArea, 'Metrics:', metrics);
            $('#metricSelect').empty().append('<option value="" disabled selected>Select Metric</option>');
            metrics.forEach(metric => {
                $('#metricSelect').append(`<option value="${metric.toLowerCase().replace(/ /g, '_')}">${metric}</option>`);
            });
        });

        // Event handler for generating a chart
        $('#generateChartBtn').on('click', function () {
            const businessArea = $('#businessAreaSelect').val();
            const metric = $('#metricSelect').val();
            const chartType = $('#chartTypeSelect').val();
            currentChartType = chartType;  // Set the current chart type
            console.log('Generating chart for:', { businessArea, metric, chartType });
            if (!businessArea || !metric || !chartType) {
                alert("Please select business area, metric, and chart type.");
                return;
            }

            // Disable the button to prevent duplicate requests
            $('#generateChartBtn').prop('disabled', true);

            const dataFilePath = `dummy/${businessArea}/${metric}.json`;
            console.log('Fetching data from:', dataFilePath);
            fetch(dataFilePath)
                .then(response => {
                    console.log('Received response:', response);
                    return response.json();
                })
                .then(chartData => {
                    console.log('Fetched data:', chartData);
                    chartCounter++;
                    pendingChartId = `chart-container-${chartCounter}`;
                    pendingChartType = chartType;
                    pendingChartData = chartData;

                    // Show the modal for entering chart name
                    $('#chartNameModal').modal('show');

                    // Re-enable the button after data is fetched and modal is shown
                    $('#generateChartBtn').prop('disabled', false);
                })
                .catch(error => {
                    console.error('Error fetching dummy data:', error);
                    // Re-enable the button if there's an error
                    $('#generateChartBtn').prop('disabled', false);
                });
        });

        // Event handler for saving chart name and generating the chart
        function saveChartName() {
            console.log('Saving chart name...');
            const chartName = $('#chartNameInput').val();
            if (!chartName) {
                alert("Please enter a chart name.");
                return;
            }

            const { x, y } = getNextPosition(); // Get next available position
            const width = 6; // Predefined width
            const height = 4; // Predefined height
            const content = `
        <div class="grid-stack-item-content" style="padding: 5px;">
          <div class="widget-title">
            <div class="widget-name">${chartName}</div>
            <span class="edit-btn">✎</span>
            <span class="save-btn" style="display: none;">✔</span>
          </div>
          <div class="chart-container" id="${pendingChartId}" style="width: 100%; height: 100%;"></div>
        </div>
      `;
            const el = placeChartContainer(pendingChartId, x, y, width, height, content);

            $('#chartNameModal').modal('hide'); // Hide the modal
            $('#chartNameInput').val(''); // Clear the input field

            console.log('Adding widget to grid...');
            grid.addWidget(el, {
                x: x,
                y: y,
                width: width,
                height: height,
                autoPosition: false
            });

            // Defer the chart generation to ensure the container is in the DOM
            setTimeout(() => {
                const container = document.getElementById(pendingChartId); // Get the DOM element directly after appending
                console.log('Chart container:', container);
                console.log('Chart container class:', container.className);

                if (container) {
                    const chart = generateHighcharts(container, pendingChartType, pendingChartData, true, chartName); // Pass the chart name as the title
                    console.log('Grid: Generated chart in container ID', container.id, 'with Highcharts index', chart.index);
                    updateCurrentLayoutContent(); // Update the current layout content display
                    updateHighchartsDataArray(); // Update Highcharts data array display
                } else {
                    console.error('Chart container not found.');
                }
            }, 0); // Use a timeout to defer execution
        }

        // Attach event listener for save button click
        $('#saveChartName').on('click', saveChartName);

        // Attach event listener for Enter key press in the input field
        $('#chartNameInput').on('keypress', function (e) {
            if (e.which === 13) { // Enter key pressed
                saveChartName();
            }
        });

        // Auto-focus the chart name input when the modal is shown
        $('#chartNameModal').on('shown.bs.modal', function () {
            $('#chartNameInput').trigger('focus');
        });

        // Event handler for deleting a widget
        $(document).on('click', '.delete-btn', function () {
            const item = $(this).closest('.grid-stack-item');
            console.log('Deleting widget:', item);
            grid.removeWidget(item[0]);
            updateCurrentLayoutContent(); // Update the current layout content display
            updateHighchartsDataArray(); // Update Highcharts data array display
        });

        // Event handler for editing a widget name
        $(document).on('click', '.edit-btn', function () {
            const content = $(this).closest('.widget-title');
            const widgetNameElement = content.find('.widget-name');
            console.log('Editing widget name:', widgetNameElement);
            widgetNameElement.attr('contenteditable', 'true').focus();
            content.find('.edit-btn').hide();
            content.find('.save-btn').show();
            placeCaretAtEnd(widgetNameElement[0]);
        });

        // Event handler for saving an edited widget name
        $(document).on('click', '.save-btn', function () {
            const content = $(this).closest('.widget-title');
            console.log('Saving edited widget name:', content.find('.widget-name'));
            content.find('.widget-name').attr('contenteditable', 'false');
            content.find('.edit-btn').show();
            content.find('.save-btn').hide();
            updateCurrentLayoutContent(); // Update the current layout content display
        });

        // Event handler for the widget name keypress (Enter key) during editing
        $(document).on('keypress', '.widget-name[contenteditable="true"]', function (e) {
            if (e.which === 13) {
                $(this).closest('.widget-title').find('.save-btn').click();
                e.preventDefault();
            }
        });

        // Enable movable and resizable behavior for grid-stack items
        grid.movable('.grid-stack-item', true);
        grid.resizable('.grid-stack-item', true);

        // Event handler for grid-stack item changes
        grid.on('change', function (event, items) {
            console.log('GridStack items changed:', items);
            updateCurrentLayoutContent(); // Update the current layout content display
            updateHighchartsDataArray(); // Update Highcharts data array display
        });

        // Event handler for grid-stack item resize stop event
        grid.on('resizestop', function (event, element) {
            console.log('GridStack item resized:', element);
            const chartContainer = $(element).find('.chart-container');
            const highchartsIndex = chartContainer.attr('data-highcharts-chart');
            console.log(`Checking if Highcharts container exists for index: ${highchartsIndex}`);
            const chart = Highcharts.charts[highchartsIndex];
            if (chart) {
                const containerWidth = chartContainer[0].offsetWidth;
                const containerHeight = chartContainer[0].offsetHeight;
                if (containerWidth && containerHeight) {
                    chart.setSize(containerWidth, containerHeight, false);
                    chart.reflow();
                    console.log(`Reflowed chart for container ID: ${chart.renderTo.id} with Highcharts index ${chart.index}`);
                } else {
                    console.log(`Invalid dimensions for container ID: ${chart.renderTo.id}`);
                }
            } else {
                console.log(`No chart instance found for Highcharts index: ${highchartsIndex}`);
            }
        });

        updateSavedLayouts();
        updateCurrentLayoutContent();
        updateHighchartsDataArray(); // Initial update for Highcharts data array display
    });

    // Utility function to get Highcharts instance by container ID
    function getHighchartsInstanceByContainerId(containerId) {
        console.log('Getting Highcharts instance by container ID:', containerId);
        const chartIndex = document.getElementById(containerId).getAttribute('data-highcharts-chart');
        return Highcharts.charts[chartIndex];
    }

    // Function to apply resizing and reflow for charts based on the saved layout
    function applyResizingFromLayout(layoutData) {
        console.log('Applying resizing and reflow from layout...');
        layoutData.highchartsDataArray.forEach(data => {
            const container = document.getElementById(data.containerId);
            if (container) {
                const options = data.options;
                options.chart.renderTo = data.containerId; // Set the renderTo property explicitly
                try {
                    console.log(`Initializing Highcharts with options:`, options);
                    const chart = Highcharts.chart(options);
                    Highcharts.charts[chart.index] = chart; // Re-register the chart instance

                    // Ensure the chart reflows correctly and fits the container
                    setTimeout(() => {
                        chart.reflow();
                        console.log(`Reflowed chart for container ID: ${data.containerId} with Highcharts index ${chart.index}`);
                    }, 0);
                } catch (error) {
                    console.error('Error recreating chart:', error, 'Options:', options);
                }
            } else {
                console.error(`Container ID ${data.containerId} not found in DOM.`);
            }
        });
    }
</script>